---
layout: lesson
title: "Lesson Three: Git - The light-weight, distributed revesion control system"
date: "3/26/2013"
subtitle: "The power of Git in managing the development of the Linux Kernel is fabled in the open source community. With the coming of new freemium hosting services like GitHub, more projects are moving to Git.<br /> "
---

<center><img src="/TerminalWorkflows/img/git_linus.jpg" height="300px" /></center><br /><br />
<h4>Introduction</h4><br /><br />
<p>Git is a fast, scalable, distributed revision control system with a rich command set that provides both high-level operations and full access to internals. It is technology that is immediately able to integrate into your development process with bindings available for migrating existing repositories.<br/><br/>
It should not just be seen as a tool for managing programmers and managing code source. `man git` describes itself as "git - the stupid content tracker". I've built CMS for journalists and managed digital rights activism. It's a tool for managing changes in <b>any text</b>. Children's school reports, gas prices, anything.
<br/><br/>
As a technology, it is split into the plumbing and porcelain commands. The core git is often called "plumbing", with the prettier user interfaces on top of it called "porcelain". You may not want to use the plumbing directly very often, but it can be good to know what the plumbing does for when the porcelain isn't flushing. To put a bit of history behind the intuition, the porcelain commands were originally shell scripts.</p>
  <p>This tutorial is split into 3 sections:</p>
  <ul class="bulleted">
      <li>
        <b>User Guide</b> - Runs through the commands you'll use on a monthly basis when working with Git. Won't go into depth on their options, I'll politely point you to the man entries. But at the end you'll be able to boot up your own repo, manage it and share it with others.
      </li>
      <li>
        <b>The Porcelain</b> - I'll run through some workflows with the porcelain commands.
      </li>
      <li>
        <b>The Plumbing</b> - I'll run through some workflows with the plumbing commands which you'll largely use when something goes wrong.
      </li>
      <li>
        <b>Workflows</b> - I'll go through some use patterns and ways to inorporate a git-based workflow with your life.</li>
  </ul>

<br /><br />
<h1>User Guide</h4><br /><br />
<h4>Installation instructions</h4><br /><br />
<p>Debian/Ubuntu: <b>sudo apt-get install git</b><br />Fedora/RHEL: <b>su -c "yum install git-core"</b></p><br />
<h4>Where To Go to Get More help</h4><br />
<ul class="bulleted">
    <li>
      <b>man</b> - e.g. man git-init. git has excellent man coverage on its commands
    </li>
    <li>
      <b>man gittutorial</b> - runs through how to import a new project into git, make changes to it, and share changes with other developers.
    </li>
    <li>
      <b><a href="http://www.git-scm.com">git-scm</a></b> - a 'prettier' presentation of command-specific help
    </li>
    <li>
    <b><a href="">Learn Git</a></b> - bite-sized pointers on how to learn git 'one commit at a time'.
    </li>
  </ul>
<h4>Working with a repository</h4><br />
  <ol>
    <li>
      <b>mkdir -p ~/Code/myFirstGitRepo && cd ~/Code/myFirstGitRepo</b> - 
    </li>
    <li>
      <b>git init .</b> - Initialize a git repo in the current directory. Git repos are stored
    </li>
    <li>
      <b>echo "This is my repo." > README.md</b> - Initialize a git repo in the current directory. All information required for git to track the history of a file across your network of contributors is stored within the .git directory.
    </li>
    <li>
      <b>git status</b> - Shows all files 'staged' and not 'staged' for commit. To add a file to the staging area, use 'git add'.
    </li>
    <li>
      <b>git add README.md</b>
    </li>
    <li>
      <b>git status</b> - Has been updated with our staged changes.
    </li>
    <li>
    <b>git rm --cached README.md</b> - File has been unstaged <b>OR</b> <b>git rm -f README.md</b> - File has been deleted<br />
    </li>
    <li>
    <b>git add README.md && git commit</b> - Git demands you comment your commits be commented. A shortcut for skipping this step is git <b>commit -m "comment_string"</b><br />
    </li>
    <li>
      <b>git remote add origin git@github.com:YourGitHubUserNam</b> - Git demands you comment your commits be commented. A shortcut for skipping this step is git <b>commit -m "comment_string"</b><br />
    </li>
    <li>
      <b>git log</b> - see your commit<br />
      <b>git log -p</b> - see your commit with additional information
    </li>
    <li>
      <b>cd .. && git clone file://myFirstGitRepo myFirstGitClone && cd myFirstGitClone</b> - clone the repository to a new directory. This is analogous to cloning the repository to a new node on your network or pushing it up to a NAS (GitHub).
    </li>
    <li>
      <b>cd ../myFirstGitRepo</b><br />
      <b>git branch updates_for_james_from_amanda master</b> - create a new branch based of our local master branch<br/>
      </li>
      <li>
        <b>echo "\nHere's my proposed changes for James, from Amanda."</b>
      </li>
      <li>
        <b>git diff -p</b> - review unstaged, uncommited changes
      </li>
      <li>
        <b>git add README.md</b><br />
      </li>
      <li>
        <b>git status -v</b> - review staged, uncommited changes<br />
      </li>
      <li>
        <b>git commit -am "Here are the changes for James from Amanda"</b> - committing the changes produces a new commit hash.
      </li>
      <li>
        <b>git log -p</b> - review commited changes and commit hash
      </li>
      <li>
        <b>git branch</b> - view all our local branches<br />
        <b>git branch -a</b> - view all known branches
      </li>
      <li>
        <b>git checkout master</b> - switching branches. Git will complain if you try to change branches with uncomitted or unstashed changes.
      </li>
      <li>
        <b>git merge updates_for_james_from_amanda</b> - merge together changes from the new branch with our 'master' branch'
      </li>
      <li>
        <b>git log --oneline --graph</b> - view changes made so far
      </li>
      <li>
        <b>cd ../myFirstGitClone</b><br />
        <b>git branch -a</b> - when you clone an existing repo, git will add it automatically as a remote called 'origin'. You can change this to whatever you want but in the early days you'll want to keep this nomenclature.
      </li>
      <li>
        Compare the following branches to get a firmer grasp:<br />
        <b>git checkout -b local_master master</b><br />
        <b>git checkout -b remote_master origin/master</b><br />
        Pay close attention to the output when these branches are created<br />
      </li>
      <li>
        <b>git checkout master</b>
      </li>
    </li>
  </ol>
<h1>The Porcelain</h4><br /><br />
  <b>
       git-add(1)<br />
           Add file contents to the index.<br />
<br />
       git-am(1)<br />
           Apply a series of patches from a mailbox.<br />
<br />
       git-archive(1)<br />
           Create an archive of files from a named tree.<br />
<br />
       git-bisect(1)<br />
           Find by binary search the change that introduced a bug.<br />
<br />
       git-branch(1)<br />
           List, create, or delete branches.<br />
<br />
       git-bundle(1)<br />
           Move objects and refs by archive.<br />
<br />
       git-checkout(1)<br />
           Checkout a branch or paths to the working tree.<br />
<br />
       git-cherry-pick(1)<br />
           Apply the changes introduced by some existing commits.<br />
<br />
       git-citool(1)<br />
           Graphical alternative to git-commit.<br />
<br />
       git-clean(1)<br />
           Remove untracked files from the working tree.<br />
<br />
       git-clone(1)<br />
           Clone a repository into a new directory.<br />
<br />
       git-commit(1)<br />
           Record changes to the repository.<br />
<br />
       git-describe(1)<br />
           Show the most recent tag that is reachable from a commit.<br />
<br />
       git-diff(1)<br />
           Show changes between commits, commit and working tree, etc.<br />
<br />
       git-fetch(1)<br />
           Download objects and refs from another repository.<br />
<br />
       git-format-patch(1)<br />
           Prepare patches for e-mail submission.<br />
<br />
       git-gc(1)<br />
           Cleanup unnecessary files and optimize the local repository.<br />
<br />
       git-grep(1)<br />
           Print lines matching a pattern.<br />
<br />
       git-gui(1)<br />
           A portable graphical interface to Git.<br />
<br />
       git-init(1)<br />
           Create an empty git repository or reinitialize an existing one.<br />
<br />
       git-log(1)<br />
           Show commit logs.<br />
<br />
       git-merge(1)<br />
           Join two or more development histories together.<br />
<br />
       git-mv(1)<br />
           Move or rename a file, a directory, or a symlink.<br />
<br />
       git-notes(1)<br />
           Add or inspect object notes.<br />
<br />
       git-pull(1)<br />
           Fetch from and merge with another repository or a local branch.<br />
<br />
       git-push(1)<br />
           Update remote refs along with associated objects.<br />
<br />
       git-rebase(1)<br />
           Forward-port local commits to the updated upstream head.<br />
<br />
       git-reset(1)<br />
           Reset current HEAD to the specified state.<br />
<br />
       git-revert(1)<br />
           Revert some existing commits.<br />
<br />
       git-rm(1)<br />
           Remove files from the working tree and from the index.<br />
<br />
       git-shortlog(1)<br />
           Summarize git log output.<br />
<br />
       git-show(1)<br />
           Show various types of objects.<br />
<br />
       git-stash(1)<br />
           Stash the changes in a dirty working directory away.<br />
<br />
       git-status(1)<br />
           Show the working tree status.<br />
<br />
       git-submodule(1)<br />
           Initialize, update or inspect submodules.<br />
<br />
       git-tag(1)<br />
           Create, list, delete or verify a tag object signed with GPG.<br />
<br />
       gitk(1)<br />
           The git repository browser.<br />
<br />
   Ancillary Commands<br />
       Manipulators:<br />
<br />
       git-config(1)<br />
           Get and set repository or global options.<br />
<br />
       git-fast-export(1)<br />
           Git data exporter.<br />
<br />
       git-fast-import(1)<br />
           Backend for fast Git data importers.<br />
<br />
       git-filter-branch(1)<br />
           Rewrite branches.<br />
<br />
       git-lost-found(1)<br />
           (deprecated) Recover lost refs that luckily have not yet been pruned.<br />
<br />
       git-mergetool(1)<br />
           Run merge conflict resolution tools to resolve merge conflicts.<br />
<br />
       git-pack-refs(1)<br />
           Pack heads and tags for efficient repository access.<br />
<br />
       git-prune(1)<br />
           Prune all unreachable objects from the object database.<br />
<br />
       git-reflog(1)<br />
           Manage reflog information.<br />
<br />
       git-relink(1)<br />
           Hardlink common objects in local repositories.<br />
<br />
       git-remote(1)<br />
           manage set of tracked repositories.<br />
<br />
       git-repack(1)<br />
           Pack unpacked objects in a repository.<br />
<br />
       git-replace(1)<br />
           Create, list, delete refs to replace objects.<br />
<br />
       git-repo-config(1)<br />
           (deprecated) Get and set repository or global options.<br />
<br />
       Interrogators:<br />
<br />
       git-annotate(1)<br />
           Annotate file lines with commit information.<br />
<br />
       git-blame(1)<br />
           Show what revision and author last modified each line of a file.<br />
<br />
       git-cherry(1)<br />
           Find commits not merged upstream.<br />
<br />
       git-count-objects(1)<br />
           Count unpacked number of objects and their disk consumption.<br />
<br />
       git-difftool(1)<br />
           Show changes using common diff tools.<br />
<br />
       git-fsck(1)<br />
           Verifies the connectivity and validity of the objects in the database.<br />
<br />
       git-get-tar-commit-id(1)<br />
           Extract commit ID from an archive created using git-archive.<br />
<br />
       git-help(1)<br />
           display help information about git.<br />
<br />
       git-instaweb(1)<br />
           Instantly browse your working repository in gitweb.<br />
<br />
       git-merge-tree(1)<br />
           Show three-way merge without touching index.<br />
<br />
       git-rerere(1)<br />
           Reuse recorded resolution of conflicted merges.<br />
<br />
       git-rev-parse(1)<br />
           Pick out and massage parameters.<br />
<br />
       git-show-branch(1)<br />
           Show branches and their commits.<br />
<br />
       git-verify-tag(1)<br />
           Check the GPG signature of tags.<br />
<br />
       git-whatchanged(1)<br />
           Show logs with difference each commit introduces.<br />
<br />
       gitweb(1)<br />
           Git web interface (web frontend to Git repositories).<br />
<br />
   Interacting with Others<br />
       These commands are to interact with foreign SCM and with other people via patch over e-mail.<br />
<br />
       git-archimport(1)<br />
           Import an Arch repository into git.<br />
<br />
       git-cvsexportcommit(1)<br />
           Export a single commit to a CVS checkout.<br />
<br />
       git-cvsimport(1)<br />
           Salvage your data out of another SCM people love to hate.<br />
<br />
       git-cvsserver(1)<br />
           A CVS server emulator for git.<br />
<br />
       git-imap-send(1)<br />
           Send a collection of patches from stdin to an IMAP folder.<br />
<br />
       git-quiltimport(1)<br />
           Applies a quilt patchset onto the current branch.<br />
<br />
       git-request-pull(1)<br />
           Generates a summary of pending changes.<br />
<br />
       git-send-email(1)<br />
           Send a collection of patches as emails.<br />
<br />
       git-svn(1)<br />
           Bidirectional operation between a Subversion repository and git.<br />
  </b>
  <br />
  <br />
<h1>The Plumbing</h4><br /><br />
       Although git includes its own porcelain layer, its low-level commands are sufficient to support development of<br />
       alternative porcelains. Developers of such porcelains might start by reading about git-update-index(1) and git-read-<br />
       tree(1).<br />
<br />
       The interface (input, output, set of options and the semantics) to these low-level commands are meant to be a lot more<br />
       stable than Porcelain level commands, because these commands are primarily for scripted use. The interface to Porcelain<br />
       commands on the other hand are subject to change in order to improve the end user experience.<br />
<br />
       The following description divides the low-level commands into commands that manipulate objects (in the repository, index,<br />
       and working tree), commands that interrogate and compare objects, and commands that move objects and references between<br />
       repositories.<br />
<br />
<b>
   Manipulation commands<br />
       git-apply(1)<br />
           Apply a patch to files and/or to the index.<br />
<br />
       git-checkout-index(1)<br />
           Copy files from the index to the working tree.<br />
<br />
       git-commit-tree(1)<br />
           Create a new commit object.<br />
<br />
       git-hash-object(1)<br />
           Compute object ID and optionally creates a blob from a file.<br />
<br />
       git-index-pack(1)<br />
           Build pack index file for an existing packed archive.<br />
<br />
       git-merge-file(1)<br />
           Run a three-way file merge.<br />
<br />
       git-merge-index(1)<br />
           Run a merge for files needing merging.<br />
<br />
       git-mktag(1)<br />
           Creates a tag object.<br />
<br />
       git-mktree(1)<br />
           Build a tree-object from ls-tree formatted text.<br />
<br />
       git-pack-objects(1)<br />
           Create a packed archive of objects.<br />
<br />
       git-prune-packed(1)<br />
           Remove extra objects that are already in pack files.<br />
<br />
       git-read-tree(1)<br />
           Reads tree information into the index.<br />
<br />
       git-symbolic-ref(1)<br />
           Read and modify symbolic refs.<br />
<br />
       git-unpack-objects(1)<br />
           Unpack objects from a packed archive.<br />
<br />
       git-update-index(1)<br />
           Register file contents in the working tree to the index.<br />
<br />
       git-update-ref(1)<br />
           Update the object name stored in a ref safely.<br />
<br />
       git-write-tree(1)<br />
           Create a tree object from the current index.<br />
<br />
   Interrogation commands<br />
       git-cat-file(1)<br />
           Provide content or type and size information for repository objects.<br />
<br />
       git-diff-files(1)<br />
           Compares files in the working tree and the index.<br />
<br />
       git-diff-index(1)<br />
           Compares content and mode of blobs between the index and repository.<br />
<br />
       git-diff-tree(1)<br />
           Compares the content and mode of blobs found via two tree objects.<br />
<br />
       git-for-each-ref(1)<br />
           Output information on each ref.<br />
<br />
       git-ls-files(1)<br />
           Show information about files in the index and the working tree.<br />
<br />
       git-ls-remote(1)<br />
           List references in a remote repository.<br />
<br />
       git-ls-tree(1)<br />
           List the contents of a tree object.<br />
<br />
       git-merge-base(1)<br />
           Find as good common ancestors as possible for a merge.<br />
<br />
       git-name-rev(1)<br />
           Find symbolic names for given revs.<br />
<br />
       git-pack-redundant(1)<br />
           Find redundant pack files.<br />
<br />
       git-rev-list(1)<br />
           Lists commit objects in reverse chronological order.<br />
<br />
       git-show-index(1)<br />
           Show packed archive index.<br />
<br />
       git-show-ref(1)<br />
           List references in a local repository.<br />
<br />
       git-tar-tree(1)<br />
           (deprecated) Create a tar archive of the files in the named tree object.<br />
<br />
       git-unpack-file(1)<br />
           Creates a temporary file with a blobâ€™s contents.<br />
       git-var(1)<br />
           Show a git logical variable.<br />
<br />
       git-verify-pack(1)<br />
           Validate packed git archive files.<br />
<br />
       In general, the interrogate commands do not touch the files in the working tree.<br />
<br />
   Synching repositories<br />
       git-daemon(1)<br />
           A really simple server for git repositories.<br />
<br />
       git-fetch-pack(1)<br />
           Receive missing objects from another repository.<br />
<br />
       git-http-backend(1)<br />
           Server side implementation of Git over HTTP.<br />
<br />
       git-send-pack(1)<br />
           Push objects over git protocol to another repository.<br />
<br />
       git-update-server-info(1)<br />
           Update auxiliary info file to help dumb servers.<br />
<br />
       The following are helper commands used by the above; end users typically do not use them directly.<br />
<br />
       git-http-fetch(1)<br />
           Download from a remote git repository via HTTP.<br />
<br />
       git-http-push(1)<br />
           Push objects over HTTP/DAV to another repository.<br />
<br />
       git-parse-remote(1)<br />
           Routines to help parsing remote repository access parameters.<br />
<br />
       git-receive-pack(1)<br />
           Receive what is pushed into the repository.<br />
<br />
       git-shell(1)<br />
           Restricted login shell for Git-only SSH access.<br />
<br />
       git-upload-archive(1)<br />
           Send archive back to git-archive.<br />
<br />
       git-upload-pack(1)<br />
           Send objects packed back to git-fetch-pack.<br />
<br />
   Internal helper commands<br />
       These are internal helper commands used by other commands; end users typically do not use them directly.<br />
<br />
       git-check-attr(1)<br />
           Display gitattributes information.<br />
<br />
       git-check-ref-format(1)<br />
           Ensures that a reference name is well formed.<br />
<br />
       git-fmt-merge-msg(1)<br />
           Produce a merge commit message.<br />
<br />
       git-mailinfo(1)<br />
           Extracts patch and authorship from a single e-mail message.<br />
<br />
       git-mailsplit(1)<br />
           Simple UNIX mbox splitter program.<br />
<br />
       git-merge-one-file(1)<br />
           The standard helper program to use with git-merge-index.<br />
<br />
       git-patch-id(1)<br />
           Compute unique ID for a patch.<br />
<br />
       git-peek-remote(1)<br />
           (deprecated) List the references in a remote repository.<br />
<br />
       git-sh-setup(1)<br />
           Common git shell script setup code.<br />
<br />
       git-stripspace(1)<br />
           Remove unnecessary whitespace.<br />
<br />
</b>
<h1>Workflows</h4><br /><br />
<h4>Bash aliases</h4><br /><br />
  <p>
    Git comes with few shortcuts for commands you use all the time. You can run your hands ragged unless you alias your favorites. Here's a suggested entry in your bash_rc / bash_profile / zshrc dotfile.
  </p>
  <hr />
  <p>
 #### Git<br />
<br />
 alias gco="git commit -am"<br />
 alias gch="git checkout"<br />
 alias gba="git branch -a"<br />
 alias gb="git branch"<br />
 alias gs="git status"<br />
  </p>
  <hr />
  <p>
    <b>gco "Commit message"</b> - faster commits<br />
    <b>gs -s</b> - faster status checks<br />
  </p>

<h4>Master is always production-ready</h4><br /><br />
  <p>
  As you've seen, branching is a very light-weight operation in Git. A branch is essentially just a pointer to a blob. This fact should be exploited to use multiple branches to track repositories at various stages of development. The 'Agile' best practise is to generally use the following branches:
  </p>
  <ul class="bulleted">
      <li>
        <b>master</b> - production-ready branch of a project. Passes all tests. Has vetted content. Contains no unfinished work. Can be deployed immediately without any questions should servers fail. Only the dev branch is merged to master. Each dev merge is tagged.
      </li>
      <li>
        <b>dev</b> - main remote branch containing work that is in progress.Does not need to pass the production test suite or have completed content but it does need to pass a suite of tests to ensure that all commiters can boot it and work on their various sections. Is frequently committed to (3+ commits per commiter per day).
      </li>
      <li>
      <b>other</b> - whilst most applications will just need the previous 2 branches, there are certain workflows that call on additional branches on the remote node. It should also be noted that you want to keep remote branches to a minimum to avoid confusion about what exactly is being worked on.
        <ul class="bulleted">
          <li>
            <b>gh-pages</b> - github will host a docs/landing page for your repo if you use the branch gh-pages. This site is entirely hosted as a gh-paes branch. 
          </li>
          <li>
            <b>legacy</b> - contains previous material to reference. This should be moved to its own repository or mothballed.
          </li>
          <li>
            <b>issueBranches</b> - some people will need to work separately of others and make breaking changes to the repository in order to achieve a desired goal. Whils they should really be adding eachother as remotes and pulling and pushing over ssh - they frequently use temporary remote branches.
        </ul>
      </li>
  </ul>
<h4>Versioned releases using submodules <b>OR</b> branches</h4><br /><br />
<p>I had an argument with a colleague about how to structure a repository for a project that requires multiple versions to be maintained indefinitely. So I've conceded that each of these workflows is acceptable. That said, I think the submodule approach is cleaner.</p>
        <ul class="bulleted">
          <li>
          <b>The Submodule approach</b> - The top-level repository contains sub-folders that are each git repositories holding the versioned code. E.g</p>
          <ul>
            <li>
            MyRepo<br />
            <ul>
              <li>
                Version 1
              </li>
              <li>
                Version 2
              </li>
              <li>
                Version 3
              </li>
              <li>
                Version 4
              </li>
              <br />
            </ul>
            </li>
          </ul>
          <p> Whenever a new version is released, clone it do a new submodule of the top level repository 'MyRepo'. Whenever a commit is made to one Version that needs to be applied to others, you can apply the commit to each of the subdirectories.<br /><br />
          TODO: Syntax for patch application to repos with common history.
          </p>
          </li>
          <li>
            <p><b>The branch approach</b> - The repository has a different branch for each stable commit. E.g</p>
          <ul>
            <li>
            MyRepo<br />
            <ul>
              <li>
               src 
              </li>
            </ul>
            </li>
          </ul>
          <p>Whenever a new version is released, create a new branch. Whenever a commit is made to one Version that needs to be applied to others, you apply the commit to each of the branches.</p>
         </li>
        </ul>

<h4>SQL-like views using branches</h4><br /><br />
<p>Branches can have contents that are entirely different from one another. As such, you can have one 'code' branch and other branches for displaying documentation and landing information. This approach is used by github in generating gh-pages. I use it as a tidy way of tying documentation to a repository.<br /><br />
Provided that your 'view' branches all generate their presentation from a directory that is shared with the master code release, you can pull changes from the code releases to update your view branches.</p>
<h4>The authortative bare repository</h4><br /><br />
  <p>
    Whilst git is designed to be a 'distributed' versioning system, it can be used as an authority by using bare repositories. In this anti-pattern, bare repositories are not directly editable and merely store the '.git' folder tracking changes to blobs, trees, commits and tags. Under this model, all developers can treat this as they would an SVN or similar repository. May be a good move if you've got committers who are stuck in their old ways.
  </p>
<h4>The Code stick</h4><br /><br />
  <p>
    I work a lot. I work at many different locations on many different machines, operating systems and architectures. I work at shared computers, machines with untrusted or non-existant internet connections and machines that will be used once and then never again. I don't want to have to spend the time setting up environments or waiting for SSH sessions to recover. <br /><br />
    
    I carry around my dotfiles, package lists and repositories on a usb. Mount the drive and work from there. As git is distributed all my changes come wherever I go and are synced to others whenever I chose to.
  </p>
<h4>GitHub's pull requests</h4><br /><br />
  <p>
  The process of developing the Linux Kernel can be characterized as an olgarchic meritocracy. Starting with Linus, who dictates all release revisions, there is a tree of maintainers extending out below him of developers with specific domain knowledge about their practises. There is a filesystem team, a networking team, a thread management team. Below these teams there are developers who implement updates to the kernel. The whole system is held together by the trust model and the idea of all patches accumulating upwards as they are tested and approved by people of increasing domain knowledge.<br /><br />
Whilst git does not support this pattern by default (as kernel developers generally email their changes to eachother), services like GitHub have an integrated 'pull request' pattern built into their workflow where maintainers are submitted commits which they can choose to apply, reject with commentary for improvement or bin.</p>

Ideas on stuff to do:

- Boot up a repo
- Set up a gitignore file
- Add a remote
- Pull changes from the remote
- Push changes to the remote
- Show branching
- Design patterns:
  * tags
  * getting reports --bisect
  * merging repositories
